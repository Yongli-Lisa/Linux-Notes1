
DMA:  
<img src="https://github.com/Yongli-Lisa/Linux-Notes1/blob/0a861b491bd7af0167b0dbf618079cfd39daf012/Img/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/DMA.JPG" width="400px">  

中断处理：  
<img src="https://github.com/Yongli-Lisa/Linux-Notes1/blob/0a861b491bd7af0167b0dbf618079cfd39daf012/Img/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86.JPG" width="300px">  

/sys 路径下面的 sysfs 文件系统。它把实际连接到系统上的设备和总线组成了一个分层的文件系统，在 /sys 路径下有下列的文件夹：    
/sys/devices 是内核对系统中所有设备的分层次的表示；  
/sys/dev 目录下一个 char 文件夹，一个 block 文件夹，分别维护一个按字符设备和块设备的主次号码 (major:minor) 链接到真实的设备 (/sys/devices 下) 的符号链接文件；  
/sys/block 是系统中当前所有的块设备；  
/sys/module 有系统中所有模块的信息；  
<img src="https://github.com/Yongli-Lisa/Linux-Notes1/blob/0a861b491bd7af0167b0dbf618079cfd39daf012/Img/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/sysfs.JPG" width="300px">  


统一接口：  
<img src="https://github.com/Yongli-Lisa/Linux-Notes1/blob/0a861b491bd7af0167b0dbf618079cfd39daf012/Img/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3.JPG" width="300px">   


字符设备工作总结：  
<img src="https://github.com/Yongli-Lisa/Linux-Notes1/blob/18d439644bdbe28a7f4a1e2db017c8368cbeab1e/Img/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93.JPG" width="300px">  

第一，有一个设备驱动程序的 ko 模块，里面有模块初始化函数、中断处理函数、设备操作函数。这里面封装了对于外部设备的操作。加载设备驱动程序模块的时候，模块初始化函数会被调用。在内核维护所有字符设备驱动的数据结构 cdev_map 里面注册，我们就可以很容易根据设备号，找到相应的设备驱动程序。  
第二，在 /dev 目录下有一个文件表示这个设备，这个文件在特殊的 devtmpfs 文件系统上，因而也有相应的 dentry 和 inode。这里的 inode 是一个特殊的 inode，里面有设备号。通过它，我们可以在 cdev_map 中找到设备驱动程序，里面还有针对字符设备文件的默认操作 def_chr_fops。  
第三，打开一个字符设备文件和打开一个普通的文件有类似的数据结构，有文件描述符、有 struct file、指向字符设备文件的 dentry 和 inode。字符设备文件的相关操作 file_operations 一开始指向 def_chr_fops，在调用 def_chr_fops 里面的 chrdev_open 函数的时候，修改为指向设备操作函数，从而读写一个字符设备文件就会直接变成读写外部设备了。  

