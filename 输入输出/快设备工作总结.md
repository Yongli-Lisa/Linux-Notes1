
块设备：   
<img src="https://github.com/Yongli-Lisa/Linux-Notes1/blob/bed5216b4e280f6eebe4aa0282cc3dfde05aff51/Img/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E5%9D%97%E8%AE%BE%E5%A4%87.JPG" width="800px">   

        
块设备遇到的文件系统：   
块设备遇到的第一个文件系统：插入盘时，mknod 会创建在 /dev 路径下面，/dev 路径下面是 devtmpfs 文件系统。会为这个块设备文件，分配一个特殊的 inode。   
块设备遇到的第二个文件系统：接下来，调用 mount，将这个块设备文件挂载到一个文件夹下面。如果这个块设备原来被格式化为一种文件系统的格式，例如 ext4，那我们调用的就是 ext4 相应的 mount 操作。这个文件系统也是向这个块设备读写文件，需要基于的主流文件系统。
（mount主要做两件事情，1是找到设备并打开它，2是填充ext4 文件系统的 super_block）   
块设备遇到的第三个文件系统：bdev 伪文件系统，所有表示块设备的 inode 都保存在伪文件系统 bdev 中，这些对用户层不可见，主要为了方便块设备的管理。   
总结：    
设备文件 /dev/xxx 在 devtmpfs 文件系统中，找到 devtmpfs 文件系统中的 inode，里面有 dev_t。我们可以通过 dev_t，在伪文件系统 bdev 中找到对应的 inode，然后根据 struct bdev_inode 找到关联的 block_device。
在找到 block_device 之后，要调用 blkdev_get 打开这个设备。blkdev_get 会调用 __blkdev_get。   


我们有一个磁盘 /dev/sda，我们既可以把它整个格式化成一个文件系统，也可以把它分成多个分区 /dev/sda1、 /dev/sda2，然后把每个分区格式化成不同的文件系统：   
<img src="https://github.com/Yongli-Lisa/Linux-Notes1/blob/bed5216b4e280f6eebe4aa0282cc3dfde05aff51/Img/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E5%9D%97%E5%88%86%E5%8C%BA%E7%BB%93%E6%9E%84.JPG" width="800px">   
